# iLmi Project - Context Documentation for AI Assistants

## ğŸ¯ PRIMARY GOAL: Smooth Native macOS/iOS Experience

**CRITICAL OBJECTIVE:** 
- Menciptakan web app yang **smooth, lancar, dan memberikan experience seperti sedang menggunakan macOS** ketika dibuka di laptop/desktop
- Menciptakan web app yang **smooth, lancar, dan memberikan experience seperti sedang menggunakan iOS** ketika dibuka di tablet dan mobile
- **Performance harus smooth seperti sistem operasi native macOS/iOS**
- **Tidak ada lag, stuttering, atau jank dalam interaksi apapun**

## Project Overview

**iLmi** adalah simulator macOS/iOS yang dibangun dengan Next.js 15 dan React 18. Project ini menampilkan desktop environment macOS dan home screen iOS dengan berbagai aplikasi yang dapat dijalankan.

**Target Experience:**
- **Desktop/Laptop**: Experience seperti menggunakan macOS - smooth animations, responsive windows, native-feeling interactions
- **Tablet/Mobile**: Experience seperti menggunakan iOS - smooth gestures, fluid animations, native-feeling touch interactions

## ğŸš€ Performance Requirements (CRITICAL)

### Smoothness Standards
- **Frame Rate**: Minimum 60 FPS (60fps) untuk semua animations dan interactions
- **Animation Smoothness**: All animations harus smooth tanpa jank atau stuttering
- **Response Time**: 
  - Mouse/Touch response: < 16ms (1 frame @ 60fps)
  - Window drag/resize: Smooth 60fps
  - App launch: < 100ms initial response
  - Swipe gestures: Smooth and responsive
  
### Performance Metrics
- **Lighthouse Performance Score**: Target 90+
- **First Contentful Paint (FCP)**: < 1.8s
- **Largest Contentful Paint (LCP)**: < 2.5s
- **Cumulative Layout Shift (CLS)**: < 0.1
- **Total Blocking Time (TBT)**: < 200ms

### User Experience Standards
- **macOS Desktop**: Windows drag harus smooth seperti native macOS
- **iOS Mobile**: Swipe gestures harus smooth seperti native iOS
- **No visible lag**: Semua interaksi harus instant dan smooth
- **Smooth transitions**: Semua page transitions harus fluid
- **Responsive feedback**: Visual feedback harus immediate

## Tech Stack

- **Framework**: Next.js 15.5.6 (App Router)
- **UI Library**: React 18.3.1
- **State Management**: Zustand 5.0.8
- **Styling**: Tailwind CSS 4.1.17
- **Icons**: Font Awesome 6.7.2 (@fortawesome/fontawesome-free)
- **Language**: TypeScript 5.9.3 (strict mode)
- **Package Manager**: pnpm

## Architecture for Smooth Performance

### 1. **RequestAnimationFrame (RAF) Pattern**
**MUST USE** for all animations and drag/resize operations:
```typescript
// âœ… CORRECT - Use RAF for smooth animations
const rafRef = useRef<number | null>(null);
const handleAnimation = () => {
  if (!rafRef.current) {
    rafRef.current = requestAnimationFrame(() => {
      // Update UI
      rafRef.current = null;
    });
  }
};

// âŒ WRONG - Direct state updates in event handlers
const handleDrag = (e) => {
  setPosition(e.clientX); // Causes jank
};
```

**Implementation Requirements:**
- âœ… Window dragging MUST use RAF
- âœ… Window resizing MUST use RAF
- âœ… Any position/transform updates MUST use RAF
- âœ… Batch updates in RAF callback
- âœ… Cancel RAF on cleanup

### 2. **State Management Optimization**
**MUST FOLLOW** Zustand best practices:
```typescript
// âœ… CORRECT - Specific selectors
const windows = useWindowsStore((state) => state.windows);

// âŒ WRONG - Entire state
const store = useWindowsStore(); // Causes unnecessary re-renders
```

**Requirements:**
- âœ… Use specific selectors (not entire state)
- âœ… Zustand 5 handles shallow comparison automatically
- âœ… Minimize store updates during animations
- âœ… Use refs for frequently updated values during drag/resize

### 3. **React Optimization Patterns**
**MUST USE** for performance:
```typescript
// âœ… CORRECT - Memoization for expensive computations
const Component = useMemo(() => {
  return getAppComponent(app.component);
}, [app?.component]);

// âœ… CORRECT - React.memo for pure components
export default memo(Component);

// âœ… CORRECT - useCallback for event handlers
const handleClick = useCallback(() => {
  // handler logic
}, [dependencies]);
```

**Requirements:**
- âœ… React.memo for frequently rendered components (Dock, AppIcon, Desktop, HomeScreen)
- âœ… useMemo for expensive computations
- âœ… useCallback for event handlers in dependencies
- âœ… Avoid inline functions in JSX when possible

### 4. **Code Splitting & Dynamic Imports**
**MUST USE** for optimal loading:
```typescript
// âœ… CORRECT - Dynamic imports
const Component = dynamic(() => import('./Component'), {
  loading: () => <LoadingComponent />,
});

// âŒ WRONG - Static imports for large components
import Component from './Component';
```

**Requirements:**
- âœ… All app components MUST use dynamic imports
- âœ… Loading states for better UX
- âœ… Reduce initial bundle size

### 5. **Debouncing & Throttling**
**MUST USE** for performance:
```typescript
// âœ… CORRECT - Debounce resize handlers
const debouncedResize = useMemo(
  () => debounce(() => handleResize(), RESIZE.DEBOUNCE_DELAY),
  []
);
```

**Requirements:**
- âœ… Debounce resize handlers (150ms)
- âœ… Throttle scroll handlers if needed
- âœ… Never call expensive operations directly in event handlers

## Project Structure

```
.
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ layout.tsx         # Root layout dengan metadata
â”‚   â”œâ”€â”€ page.tsx           # Home page (device detection & routing)
â”‚   â””â”€â”€ globals.css        # Global Tailwind styles
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Desktop/           # macOS Desktop components
â”‚   â”‚   â”œâ”€â”€ Desktop.tsx    # Main desktop container
â”‚   â”‚   â”œâ”€â”€ MenuBar.tsx    # Top menu bar
â”‚   â”‚   â”œâ”€â”€ Dock.tsx       # Bottom dock
â”‚   â”‚   â”œâ”€â”€ Window.tsx     # Draggable/resizable windows
â”‚   â”‚   â””â”€â”€ ControlCenter.tsx
â”‚   â”œâ”€â”€ Mobile/            # iOS Mobile components
â”‚   â”‚   â”œâ”€â”€ HomeScreen.tsx # Main home screen
â”‚   â”‚   â”œâ”€â”€ StatusBar.tsx  # Top status bar
â”‚   â”‚   â”œâ”€â”€ AppIcon.tsx    # App icon component
â”‚   â”‚   â””â”€â”€ Widget.tsx     # iOS widgets
â”‚   â”œâ”€â”€ Apps/              # Application components
â”‚   â”‚   â”œâ”€â”€ Calculator.tsx
â”‚   â”‚   â”œâ”€â”€ Notes.tsx
â”‚   â”‚   â”œâ”€â”€ Finder.tsx     # macOS only
â”‚   â”‚   â”œâ”€â”€ Files.tsx      # iOS only
â”‚   â”‚   â”œâ”€â”€ Terminal.tsx   # macOS only
â”‚   â”‚   â”œâ”€â”€ Settings.tsx
â”‚   â”‚   â””â”€â”€ Photos.tsx     # iOS only
â”‚   â””â”€â”€ ErrorBoundary.tsx  # Error handling component
â”œâ”€â”€ stores/                # Zustand state management
â”‚   â”œâ”€â”€ apps.ts            # App registry & running apps
â”‚   â”œâ”€â”€ windows.ts         # Window state management
â”‚   â””â”€â”€ controlCenter.ts   # Control Center state
â”œâ”€â”€ utils/                 # Utility functions
â”‚   â”œâ”€â”€ deviceDetection.ts # Device/platform detection
â”‚   â”œâ”€â”€ deviceInfo.ts      # Battery/network info
â”‚   â”œâ”€â”€ appComponents.tsx  # Dynamic component mapping
â”‚   â””â”€â”€ debounce.ts        # Debounce utility
â”œâ”€â”€ types/                 # TypeScript type definitions
â”‚   â”œâ”€â”€ index.ts           # Main types
â”‚   â””â”€â”€ navigator.ts       # Navigator API types
â””â”€â”€ constants/             # Application constants
    â””â”€â”€ index.ts           # Window sizes, delays, etc.
```

## ğŸ¨ macOS Experience Requirements (Desktop/Laptop)

### Window System
- **Smooth Dragging**: Windows harus dapat di-drag dengan smooth 60fps
- **Smooth Resizing**: Resize windows harus smooth tanpa lag
- **Instant Feedback**: Visual feedback saat drag/resize harus instant
- **Native Feel**: Interaksi harus terasa seperti native macOS windows
- **Z-index Management**: Focused window selalu di atas dengan smooth transition

### Animations
- **Window Open/Close**: Smooth fade/scale animation
- **Minimize/Maximize**: Smooth transition seperti macOS
- **Dock Animations**: Smooth hover effects dan scaling
- **Menu Bar**: Smooth interactions dan transitions

### Performance Standards
- **Window Drag**: 60fps, no jank, smooth movement
- **Multiple Windows**: Tetap smooth meskipun banyak windows terbuka
- **Resize Performance**: Smooth meskipun window besar

## ğŸ“± iOS Experience Requirements (Tablet/Mobile)

### Gestures & Touch
- **Smooth Swipes**: Swipe gestures harus smooth seperti iOS native
- **Touch Response**: Touch response time < 16ms
- **Gesture Recognition**: Accurate gesture detection
- **Swipe to Close**: Smooth swipe down to close app
- **Pull to Refresh**: Smooth pull gesture (if implemented)

### Animations
- **App Launch**: Smooth full-screen transition
- **Home Screen**: Smooth app icon animations
- **Page Transitions**: Smooth page transitions
- **Status Bar**: Smooth updates dan animations

### Performance Standards
- **Scroll Performance**: Smooth 60fps scrolling
- **Touch Interactions**: Instant response
- **Animation Smoothness**: All animations must be smooth

## Key Architecture Patterns

### 1. State Management (Zustand)
- **apps.ts**: Manages app registry and running apps
  - `iosApps`, `macosApps`: Pre-computed platform-specific apps
  - `runningApps`: Set of currently running app IDs
- **windows.ts**: Manages window state (position, size, focus, z-index)
  - Zustand 5 automatically does shallow comparison (no need for `shallow` parameter)
  - **IMPORTANT**: Minimize store updates during drag/resize - use refs instead
- **controlCenter.ts**: Simple toggle state for Control Center

### 2. Component Architecture
- **Desktop Mode**: MenuBar + Windows + Dock
- **Mobile Mode**: StatusBar + HomeScreen + Dock (bottom apps)
- **Apps**: Dynamic imports for code splitting (`utils/appComponents.tsx`)
- **Error Boundaries**: Wrapped around Desktop & HomeScreen

### 3. Device Detection
- Auto-detects platform (macOS/iOS) based on screen size and touch capability
- Routes to appropriate UI (Desktop.tsx or HomeScreen.tsx)
- **Debounced resize handler (150ms)** to prevent excessive re-renders
- **CRITICAL**: Device detection must not cause lag or delay

### 4. Window System (macOS) - Performance Critical
**MUST IMPLEMENT:**
- âœ… Draggable windows with **RequestAnimationFrame**
- âœ… Resizable windows with **RequestAnimationFrame**
- âœ… **Batched updates** - collect all updates, apply in single RAF
- âœ… **Ref-based state** - use refs for drag/resize state, only update store on mouseup
- âœ… **Z-index management** - smooth transitions
- âœ… **Minimize/Maximize/Close** - smooth animations

**Performance Pattern:**
```typescript
// âœ… CORRECT Pattern for Window Dragging
const stateRef = useRef({ /* drag state */ });
const rafRef = useRef<number | null>(null);
const pendingUpdateRef = useRef({ /* updates */ });

const handleMouseMove = useCallback((e: MouseEvent) => {
  // Update refs (no re-render)
  stateRef.current.x = e.clientX;
  
  // Batch updates
  pendingUpdateRef.current.x = calculatedX;
  
  // Schedule RAF update
  if (!rafRef.current) {
    rafRef.current = requestAnimationFrame(() => {
      // Single store update (causes 1 re-render)
      storeRef.current.updateWindow(id, pendingUpdateRef.current);
      pendingUpdateRef.current = null;
      rafRef.current = null;
    });
  }
}, []);
```

### 5. App System
- Apps defined in `stores/apps.ts` with metadata (id, name, icon, component, platform)
- Component mapping centralized in `utils/appComponents.tsx`
- **Dynamic imports** with loading states (for code splitting)
- Platform-specific filtering (ios, macos, both)

## ğŸ› ï¸ Implementation Guidelines for Smooth Performance

### Creating Smooth Animations

**1. Use CSS Transitions Instead of JavaScript Animations**
```typescript
// âœ… CORRECT - CSS transitions
<div className="transition-all duration-200 ease-out" />

// âŒ AVOID - JavaScript-based frame-by-frame animations
useEffect(() => {
  const interval = setInterval(() => {
    setPosition(prev => prev + 1); // Causes re-renders every frame
  }, 16);
}, []);
```

**2. Use Transform & Opacity for Animations**
```css
/* âœ… CORRECT - GPU-accelerated properties */
transform: translateX(100px);
opacity: 0.5;

/* âŒ AVOID - Layout-triggering properties */
left: 100px;
width: 200px;
```

**3. Use will-change for Known Animations**
```css
/* âœ… CORRECT - Hint browser for optimization */
will-change: transform;

/* Apply before animation, remove after */
```

### Optimizing Window Drag/Resize

**MUST FOLLOW THIS PATTERN:**
```typescript
// 1. Use refs for frequently updated values
const stateRef = useRef({
  isDragging: false,
  dragStart: { x: 0, y: 0 },
  windowId: '',
});

// 2. Update refs in event handlers (no re-render)
const handleMouseMove = (e: MouseEvent) => {
  stateRef.current.x = e.clientX;
  stateRef.current.y = e.clientY;
};

// 3. Batch updates with RAF
const rafRef = useRef<number | null>(null);
const pendingUpdate = useRef({});

if (!rafRef.current) {
  rafRef.current = requestAnimationFrame(() => {
    // Single store update
    updateWindow(stateRef.current.windowId, pendingUpdate.current);
    rafRef.current = null;
  });
}

// 4. Only update store on mouseup (final position)
const handleMouseUp = () => {
  if (rafRef.current) cancelAnimationFrame(rafRef.current);
  // Final update
  updateWindow(stateRef.current.windowId, pendingUpdate.current);
};
```

### Optimizing Touch Gestures (iOS)

**Smooth Swipe Pattern:**
```typescript
// âœ… CORRECT - Smooth touch handling
const [touchStart, setTouchStart] = useState({ x: 0, y: 0 });

const handleTouchMove = (e: TouchEvent) => {
  // Use passive listeners for better performance
  const deltaX = e.touches[0].clientX - touchStart.x;
  const deltaY = e.touches[0].clientY - touchStart.y;
  
  // Apply transform directly (no state update during drag)
  element.style.transform = `translateY(${deltaY}px)`;
};

// Update state only on touch end
const handleTouchEnd = () => {
  // Calculate final position
  // Apply smooth transition
};
```

## Coding Standards

### TypeScript
- **Strict mode enabled**: No implicit any
- **Type definitions**: All types in `types/` directory
- **No `any` types**: Use proper types or type assertions with interfaces
- **Type exports**: Centralized in `types/index.ts`

### React Patterns
- **'use client'**: All interactive components are client components
- **useMemo/useCallback**: MUST use for expensive computations and event handlers
- **React.memo**: MUST apply to frequently re-rendered components (Dock, AppIcon, Desktop, HomeScreen)
- **Custom hooks**: When logic is reusable
- **Error boundaries**: For graceful error handling

### Performance Patterns (MANDATORY)
- âœ… **RequestAnimationFrame** for all position/transform updates
- âœ… **Refs** for frequently updated values during drag/resize
- âœ… **Batched updates** - collect updates, apply in single RAF
- âœ… **Debounce** resize handlers (150ms)
- âœ… **Dynamic imports** for code splitting
- âœ… **CSS transitions** instead of JS animations when possible
- âœ… **Transform/opacity** instead of layout properties
- âŒ **NEVER** update state directly in mousemove/touchmove handlers
- âŒ **NEVER** cause layout thrashing
- âŒ **NEVER** block main thread with expensive operations

### State Management
- **Zustand stores**: Single responsibility per store
- **Selectors**: Use specific selectors, not entire state
- **No shallow parameter**: Zustand 5 handles this automatically
- **Immutable updates**: Always return new state objects
- **Minimize updates**: During drag/resize, minimize store updates

### Naming Conventions
- **Components**: PascalCase (e.g., `Window.tsx`, `HomeScreen.tsx`)
- **Utilities**: camelCase (e.g., `deviceDetection.ts`, `debounce.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `WINDOW.MIN_WIDTH`)
- **Types/Interfaces**: PascalCase (e.g., `WindowState`, `DeviceInfo`)

### File Organization
- **One component per file**: Named exports default export
- **Co-located types**: Types near components when component-specific
- **Shared types**: In `types/` directory
- **Constants**: Centralized in `constants/index.ts`

## Important Constants

```typescript
// Window sizes
WINDOW.MIN_WIDTH = 400
WINDOW.MIN_HEIGHT = 300
WINDOW.DEFAULT_WIDTH = 800
WINDOW.DEFAULT_HEIGHT = 600
WINDOW.Z_INDEX_START = 1000

// Performance & Delays
RESIZE.DEBOUNCE_DELAY = 150ms  // Resize handler debounce
RESIZE.MIN_SWIPE_DISTANCE = 50px  // Minimum swipe distance

// Dock
DOCK.IOS_APPS_COUNT = 4  // Last N apps in iOS dock

// Animation durations
ANIMATION.DURATION.FAST = 100ms
ANIMATION.DURATION.NORMAL = 200ms
ANIMATION.DURATION.SLOW = 300ms
```

## Best Practices for Smooth Performance

### Performance (MANDATORY)
- âœ… **RequestAnimationFrame** for all animations and drag/resize
- âœ… **Dynamic imports** for code splitting (reduce initial bundle)
- âœ… **Debounce** resize handlers (150ms)
- âœ… **React.memo** for pure components
- âœ… **useMemo** for expensive computations
- âœ… **useCallback** for event handlers in dependencies
- âœ… **Refs** for frequently updated values during animations
- âœ… **Batched updates** - collect updates, apply in single operation
- âœ… **CSS transitions** instead of JS animations when possible
- âœ… **Transform/opacity** for animations (GPU-accelerated)
- âœ… **will-change** for known animations
- âœ… **Passive event listeners** for touch/scroll events

### Code Quality
- âœ… ESLint configured (Next.js + TypeScript rules)
- âœ… Prettier configured (auto-format on save)
- âœ… No unused variables (prefix with `_` if intentionally unused)
- âœ… All dependencies in hooks listed
- âœ… Type safety enforced

### Image Optimization
- âœ… Use Next.js `Image` component (not `<img>`)
- âœ… Use `unoptimized` prop for external images (Unsplash)
- âœ… Proper width/height attributes
- âœ… Lazy loading for images below fold

### Error Handling
- âœ… Error boundaries for Desktop & Mobile modes
- âœ… Graceful fallbacks for API failures (battery, network)
- âœ… Try-catch for async operations

## Common Patterns

### Adding New App
1. Add app metadata to `stores/apps.ts` (defaultApps array)
2. Create component in `components/Apps/`
3. Add component mapping in `utils/appComponents.tsx`
4. Export component type in `types/index.ts` (AppComponentName)

### Window Operations (Performance Critical)
```typescript
// âœ… CORRECT Pattern for Window Operations
// 1. Use refs during drag/resize
const stateRef = useRef({ /* state */ });

// 2. Batch updates with RAF
const rafRef = useRef<number | null>(null);
const pendingUpdate = useRef({});

const handleMouseMove = useCallback((e: MouseEvent) => {
  // Update refs (no re-render)
  const updates = calculateUpdates(e);
  Object.assign(pendingUpdate.current, updates);
  
  // Schedule RAF
  if (!rafRef.current) {
    rafRef.current = requestAnimationFrame(() => {
      updateWindow(id, pendingUpdate.current);
      pendingUpdate.current = {};
      rafRef.current = null;
    });
  }
}, []);

// 3. Final update on mouseup
const handleMouseUp = useCallback(() => {
  if (rafRef.current) cancelAnimationFrame(rafRef.current);
  updateWindow(id, pendingUpdate.current);
}, []);
```

### Device Detection
```typescript
const deviceInfo = detectDevice();
// Returns: { platform, isMobile, isTablet, isDesktop, screenWidth, screenHeight, hasTouch }
```

## Build & Development

### Scripts
- `pnpm dev` - Development server
- `pnpm build` - Production build
- `pnpm start` - Production server
- `pnpm lint` - ESLint check
- `pnpm lint:fix` - Fix ESLint errors
- `pnpm format` - Format with Prettier

### Build Output
- Static pages prerendered
- Code splitting with dynamic imports
- Optimized bundle sizes

## âš ï¸ Critical Rules for Smooth Performance

### DO'S (MUST FOLLOW)
1. âœ… **ALWAYS use RequestAnimationFrame** for position/transform updates
2. âœ… **ALWAYS use refs** for values updated frequently during drag/resize
3. âœ… **ALWAYS batch updates** - collect all updates, apply in single RAF
4. âœ… **ALWAYS debounce** resize handlers (150ms)
5. âœ… **ALWAYS use React.memo** for frequently rendered components
6. âœ… **ALWAYS use CSS transitions** instead of JS animations when possible
7. âœ… **ALWAYS use transform/opacity** for animations
8. âœ… **ALWAYS test** performance - ensure 60fps
9. âœ… **ALWAYS minimize** store updates during animations
10. âœ… **ALWAYS use** dynamic imports for large components

### DON'TS (NEVER DO)
1. âŒ **NEVER update state** directly in mousemove/touchmove handlers
2. âŒ **NEVER cause** layout thrashing
3. âŒ **NEVER block** main thread with expensive operations
4. âŒ **NEVER use** setInterval for animations (use RAF)
5. âŒ **NEVER import** large components statically (use dynamic imports)
6. âŒ **NEVER skip** memoization for expensive computations
7. âŒ **NEVER use** layout properties (left, top, width) for animations
8. âŒ **NEVER update** store on every frame during drag/resize
9. âŒ **NEVER cause** unnecessary re-renders
10. âŒ **NEVER ignore** performance warnings

## Important Notes

1. **Variable Naming**: Avoid naming variables `window` (conflicts with global `window` object). Use `windowState` instead.

2. **Shallow Comparison**: Zustand 5 handles shallow comparison automatically. Don't pass `shallow` as second parameter.

3. **Dynamic Imports**: All app components use dynamic imports. Don't import them statically.

4. **Type Safety**: Always use proper types. Don't use `any` - create proper type definitions.

5. **Constants**: Use constants from `constants/index.ts` instead of magic numbers.

6. **Platform Detection**: Check `deviceInfo.platform === 'macos'` to route to appropriate UI.

7. **Error Boundaries**: Always wrap major components (Desktop, HomeScreen) with ErrorBoundary.

8. **Performance First**: Every feature must be implemented with performance in mind. Smooth 60fps is non-negotiable.

9. **Test Performance**: Always test performance after implementing features. Use browser DevTools Performance tab.

10. **Native Feel**: All interactions should feel native - instant response, smooth animations, no jank.

## When Adding Features

1. **Check existing patterns**: Follow existing code structure
2. **Update types**: Add types to `types/` if needed
3. **Update constants**: Add to `constants/index.ts` if needed
4. **Test build**: Run `pnpm build` to ensure no errors
5. **Test performance**: Ensure 60fps smooth animations
6. **Follow conventions**: Use existing naming and structure patterns
7. **Use RAF**: For any position/transform updates
8. **Minimize re-renders**: Use refs and memoization appropriately

## Performance Testing Checklist

Before considering a feature complete:
- [ ] Test window drag performance (must be 60fps)
- [ ] Test window resize performance (must be 60fps)
- [ ] Test touch gestures on mobile (must be smooth)
- [ ] Test with multiple windows open (must remain smooth)
- [ ] Check Lighthouse Performance score (target 90+)
- [ ] Verify no layout thrashing
- [ ] Verify no main thread blocking
- [ ] Test on different devices/browsers
